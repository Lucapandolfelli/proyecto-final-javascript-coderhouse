{"version":3,"names":[],"mappings":"","sources":["script.js"],"sourcesContent":["/* \r\nCreamos un objeto teniendo en cuenta los parámetros que nos devuelve la API en la docmuentación de la misma. \r\nLink: https://www.pexels.com/es-es/api/documentation/#photos-overview.\r\n*/\r\nclass Photo {\r\n    /* constructor(id, url, src, photographer, alt){\r\n        this.id = id; // Nro identificador de cada foto en particular.\r\n        this.url = url; // URL de la imagen original subida en Pexels.\r\n        this.src = src; // URL de la imagen para ser utilizada en nuestro proyecto.\r\n        this.photographer = photographer; // Nombre del fotografo.\r\n        this.alt = alt; // Texto descriptivo de la imagen el cual usa la API para filtrar y devolver resultados de búsqueda.\r\n    } */\r\n    // Creamos el constructor de la clase a partir de las propiedades del objeto dado por un json de una API.\r\n    constructor(json){\r\n        Object.assign(this, json);\r\n    }\r\n    showModal(){\r\n        Swal.fire({\r\n            imageUrl: this.src,\r\n            imageHeight: 500,\r\n            imageAlt: this.alt\r\n        });\r\n    }\r\n}\r\n\r\n// Creamos una función para generar Id's aleatorios. \r\nconst generateId = () => {\r\n    let id = Math.floor(Math.random() * 999) + 1;\r\n    return id;\r\n}\r\n\r\n// Creamos un array que simule el json que devuelve una API. Los primeros 8 elementos representan fotos random. El resto representan fotos para ser buscadas.\r\nconst apiPhotos = [\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/example (1).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/example (2).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/example (3).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/example (4).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/example (5).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/example (6).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/example (7).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/example (8).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/caballomontaña.jpg', photographer: 'Jose Molina', alt: 'Caballos en montaña'},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/gatosaltando.jpg', photographer: 'Ignacio Fernandez', alt: 'Gato saltando'},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/formula1.jpg', photographer: 'Martin Caro', alt: 'Autos de Formula 1'},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/buenosaires.jpg', photographer: 'Beatriz Quiroga', alt: 'Buenos Aires'},\r\n    {id: generateId(), url: 'ejemploURL', src: './dist/assets/images/personamontaña.jpg', photographer: 'Jose Molina', alt: 'Persona en montaña'}\r\n];\r\n\r\nlet errorAlert = document.getElementById('errorAlert');\r\nlet clearInputButton = document.getElementById('clearInput');\r\nlet searchForm = document.getElementById('searchForm');\r\nlet gallery = document.getElementById('gallery');\r\nlet galleryContainer = document.getElementById('galleryContainer');\r\n\r\n\r\n// Creamos una función que nos permita eliminar todos los hijos de un elemento.\r\nconst removeAllChild = (parent) => {\r\n    // Evalua que mientras tenga hijos, los va a eliminar.\r\n    while (parent.firstChild) {\r\n        parent.removeChild(parent.firstChild);\r\n    }\r\n}\r\n\r\n// Creamos una función que nos permita crear nuevos elementos (fotos) para la galería.\r\nconst createNewGalleryItem = (photoObject) => {\r\n    // Creamos un nuevo objeto 'Photo' a partir del objeto que nos dá el 'json'.\r\n    const photo = new Photo(photoObject);\r\n    // Creamos un nuevo elemento article.\r\n    let newGalleryItem = document.createElement('article');\r\n    // Le asignamos la clase que define los estilos que poseerán las fotos.\r\n    newGalleryItem.classList.add('gallery__item');\r\n    newGalleryItem.setAttribute('photoId',`${photo.id}`)\r\n    // Y le ponemos una etiqueta img con los datos del objeto para que se muestren.\r\n    newGalleryItem.innerHTML = `<img src=\"${photo.src}\" alt=\"${photo.alt}\"></img>`;\r\n    // Y por último le agregamos ese nuevo elemento a la galería. Utilicé el 'prepend' ya que quiero que se agregue al principio, para respetar el orden que simulo en el array.\r\n    galleryContainer.prepend(newGalleryItem);\r\n    // Retornamos el objeto 'Photo' para poder utilizarlo posteriormente.\r\n    return photo;\r\n}\r\n\r\n// Creamos una función que nos permita saber si lo que ingresa el usuario coincide de alguna forma con el atributo 'Alt' de alguna foto. \r\nconst filterPhotos = (search) => {\r\n    // Filtramos el array de objetos para ver si la palabra buscada se encuentra en el alt de la foto. \r\n    let filteredPhotos = apiPhotos.filter(photo => photo.alt.toLowerCase().includes(search));\r\n    /* \r\n    Array.filter() devuelve un array nuevo si se cumple la condición y uno vacío si no se cumple. \r\n    Comprobamos si el array está vacío, es decir, que la plabra buscada no matcheó con ningún objeto de nuestro array(simulador de base de datos). \r\n    */\r\n    if (filteredPhotos.length === 0){\r\n        // Creamos un elemento h2 para poder asignarle el error.\r\n        let h2 = document.createElement('h2');\r\n        // Le asignamos el error al elemento h2.\r\n        h2.innerText = `No se pudo encontrar ninguna foto relacionada a \"${search}\".`;\r\n        // Lo insertamos dentro de la galería pero antes del contenedor.\r\n        gallery.insertBefore(h2, galleryContainer);\r\n        // Borramos todos los hijos del contenedor.\r\n        removeAllChild(galleryContainer);\r\n    } else{\r\n        // Eliminamos todas las fotos de la gelería.\r\n        removeAllChild(galleryContainer);\r\n        // Aplicando la función 'forEach' de orden superior. Por cada foto filtrada devolvemos un nuevo elemento para la galería.\r\n        filteredPhotos.forEach((photoObject) => {\r\n            // Llamamos la función que crea un nuevo elemento de la galería. 'photo' simula un objeto de un json que nos devuelve la API.\r\n            let photo = createNewGalleryItem(photoObject);\r\n            let galleryItem = document.querySelector('article');\r\n            galleryItem.addEventListener('click', () => photo.showModal());\r\n        });\r\n    }\r\n}\r\n\r\n// Creamos una función que al cargarse la página simule que se trajeron fotos aleatoriamente. La misma cargará 8 fotos.\r\nconst getInitialRandomPhotos = (photosArray) => {\r\n    let firstEightItems = photosArray.slice(0, 8);\r\n    firstEightItems.forEach((photoObject) => {\r\n        let photo = createNewGalleryItem(photoObject);\r\n        let galleryItem = document.querySelector('article');\r\n        galleryItem.addEventListener('click', () => photo.showModal());\r\n    });\r\n}\r\n\r\n// Creamos una función que nos permita tomar lo que el usuario ingresa en la barra de búsqueda y fijarnos si matchea con alguna de las fotos que tenemos guardadas en el array (simulador de base de datos).\r\nconst getSearchedPhotos = (e) => {\r\n    // Evitamos el funcionamiento por defualt del evento submit.\r\n    e.preventDefault();\r\n    // Tomamos al input del form y lo almacenamos.\r\n    let inputSearch = e.target.querySelector('input');\r\n    // Y también guardamos el value en otra.\r\n    const userSearch = inputSearch.value;\r\n    // Validamos el value del input.\r\n    if (userSearch.length > 3){\r\n        // Llamamos a la función que filtra.\r\n        filterPhotos(userSearch);\r\n        errorAlert.innerText = '';\r\n    } else{\r\n        // Sino, avisamos el error.\r\n        errorAlert.innerText = 'Debe introducir una palabra mayor a 3 letras.';\r\n        // Creamos un timer que limpie el 'errorAlert' despues de 1.5 segundos.\r\n        setTimeout(() => {\r\n            errorAlert.innerText = '';\r\n        }, 1500);\r\n    }\r\n}\r\n\r\n// Evento submit del form, donde se llama a una función que trae las fotos a partir de la búsqueda.\r\nsearchForm.addEventListener('submit', (e) => getSearchedPhotos(e));\r\n\r\n// Cuando se carge la ventana, llamamos a la función que nos carga 8 fotos simulando que son fotos aleatorias.\r\ndocument.addEventListener('DOMContentLoaded', getInitialRandomPhotos(apiPhotos));\r\n\r\n// Botón para limpiar el input del form.\r\nclearInputButton.addEventListener('click', () => {\r\n    // Limpiamos el input.\r\n    document.getElementById('searchInput').value = '';\r\n    // Cuando la galería tiene 3 hijos es porque no se tuvo que crear el h2 para error. Sino, si se tuvo que crear el h2 por lo que tiene más hijos.\r\n    if (gallery.childNodes.length == 3){\r\n        // Borra los hijos del contenedor de la galería.\r\n        removeAllChild(galleryContainer);\r\n        // Carga las fotos aleatorias del principio.\r\n        getInitialRandomPhotos(apiPhotos);\r\n    }else{\r\n        // Borra el h2 con el error.\r\n        gallery.childNodes[1].remove();\r\n        // Carga las fotos aleatorias del principio.\r\n        getInitialRandomPhotos(apiPhotos);\r\n    }\r\n});\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Toggle theme functionality\r\n\r\nlet toggleTheme = document.getElementById('toggleTheme');\r\nlet ball = document.getElementById('ball');\r\nlet theme = localStorage.getItem('theme');\r\n\r\n// Creamos una función que nos permita habiltar el tema oscuro de la página, agregando la clase correspondiente al body y seteando el local storage para guardar el modo.\r\nconst enableDarkTheme = () => {\r\n    document.body.classList.add('dark-theme');\r\n    localStorage.setItem('theme', 'darkTheme');\r\n    ball.style.transform = 'translateX(20px)';\r\n}\r\n\r\n// Creamos una función que nos permita deshabiltar el tema oscuro de la página, removiendo la clase al body y seteando el local storage para guardar el modo.\r\nconst disableDarkTheme = () => {\r\n    document.body.classList.remove('dark-theme');\r\n    localStorage.setItem('theme', 'normal');\r\n    ball.style.transform = 'translateX(0)';\r\n}\r\n\r\ntheme === 'darkTheme' ? enableDarkTheme() : disableDarkTheme();\r\n\r\n// Cuando se aplique el evento click al botón toggle, si el local storage 'theme' no es 'darkTheme', lo habilitamos y sino lo deshabilitamos.\r\ntoggleTheme.addEventListener('click', () => {\r\n    // Actualizamos el local storage cuando se hace click.\r\n    theme = localStorage.getItem('theme');\r\n    theme != 'darkTheme' ? enableDarkTheme() : disableDarkTheme();\r\n});\r\n\r\n"],"file":"script.js"}