{"version":3,"names":[],"mappings":"","sources":["script.js"],"sourcesContent":["/* \r\nCreamos un objeto teniendo en cuenta los parámetros que nos devuelve la API en la docmuentación de la misma. \r\nLink: https://www.pexels.com/es-es/api/documentation/#photos-overview.\r\n*/\r\nclass Photo {\r\n    // Creamos el constructor de la clase a partir de las propiedades del objeto dado por un json de una API.\r\n    constructor(json){\r\n        Object.assign(this, json);\r\n    }\r\n    /* showModal(){\r\n        Swal.fire({\r\n            width: '50rem',\r\n            imageUrl: this.src.original,\r\n            imageWidth: '60%',  \r\n            showConfirmButton: false,  \r\n            imageAlt: this.alt\r\n        });\r\n    } */\r\n}\r\n\r\n// La API key que pedí a la API de Pexels.\r\nconst API_KEY = '563492ad6f9170000100000124f75ece770b47a49b4bfa89770d506a';\r\n// Guardo los headers en una constante para usarlos cuando necesite hacer un fetch.\r\nconst HEADERS = {\r\n    method: 'GET', \r\n    headers: {\r\n        Accept: 'application/json',\r\n        Authorization: API_KEY\r\n    }\r\n}\r\n\r\nlet loadMoreBtn = document.getElementById('loadMoreBtn');\r\nlet errorAlert = document.getElementById('errorAlert');\r\nlet clearInputButton = document.getElementById('clearInput');\r\nlet searchForm = document.getElementById('searchForm');\r\nlet gallery = document.getElementById('gallery');\r\nlet galleryContainer = document.getElementById('galleryContainer');\r\n\r\n\r\n// Creamos una función que nos permita eliminar todos los hijos de un elemento.\r\nconst removeAllChild = (parent) => {\r\n    // Evalua que mientras tenga hijos, los va a eliminar.\r\n    while (parent.firstChild) {\r\n        parent.removeChild(parent.firstChild);\r\n    }\r\n}\r\n\r\nlet pageIndex = 1;\r\nlet searchValue;\r\n\r\nconst fetchPhotos = async (baseURL) => {\r\n    const res = await fetch(baseURL, HEADERS);\r\n    const data = await res.json();\r\n    return data;\r\n}\r\n\r\nconst validateSearchValue = (searchValue) => {\r\n    if (searchValue.length < 3){\r\n        // Avisamos el error.\r\n        errorAlert.innerText = 'Debe introducir una palabra mayor a 3 letras.';\r\n        // Creamos un timer que limpie el 'errorAlert' despues de 1.5 segundos.\r\n        setTimeout(() => {\r\n            errorAlert.innerText = '';\r\n        }, 1500);\r\n    }else{\r\n        return true;\r\n    }\r\n}\r\n\r\nconst generateHTML = (data, photoType) => {\r\n    data.photos.forEach((photoObject) => {\r\n        const photo = new Photo(photoObject);\r\n        // Creamos un nuevo elemento article.\r\n        let newGalleryItem = document.createElement('article');\r\n        // Le asignamos la clase que define los estilos que poseerán las fotos.\r\n        newGalleryItem.classList.add('gallery__item');\r\n        newGalleryItem.setAttribute('data-photo', photoType);\r\n        // Y le ponemos una etiqueta img con los datos del objeto para que se muestren.\r\n        newGalleryItem.innerHTML = `<img src=\"${photo.src.large}\" alt=\"${photo.alt}\"></img>`;\r\n        // Y por último le agregamos ese nuevo elemento a la galería.\r\n        galleryContainer.append(newGalleryItem);\r\n    });\r\n}\r\n\r\n// Creamos una función que nos devuelva las fotos a partir de lo ingresado por el usuario en la barra de búsqueda.\r\nconst getSearchedPhotos = async (e) => {\r\n    e.preventDefault();\r\n    searchValue = e.target.querySelector('input').value;\r\n    if (validateSearchValue(searchValue) === true){\r\n        const data = await fetchPhotos(`https://api.pexels.com/v1/search?query=${searchValue}&per_page=16`);\r\n        if (!data.next_page){\r\n            loadMoreBtn.style.display = 'none'\r\n        }\r\n        removeAllChild(galleryContainer);\r\n        generateHTML(data, 'search');\r\n    }\r\n}\r\n\r\nconst getMoreSearchedPhotos = async (index) => {\r\n    const data = await fetchPhotos(`https://api.pexels.com/v1/search?query=${searchValue}&per_page=16&page=${index}`);\r\n    if (!data.next_page){\r\n        loadMoreBtn.style.display = 'none'\r\n    }\r\n    generateHTML(data, 'search');\r\n}\r\n\r\n// Creamos una función que nos devuelva fotos aleatorias.\r\nconst getInitialRandomPhotos = async (index) => {\r\n    const data = await fetchPhotos(`https://api.pexels.com/v1/curated?per_page=16&page=${index}`);\r\n    if (!data.next_page){\r\n        loadMoreBtn.style.display = 'none'\r\n    }\r\n    generateHTML(data, 'curated');\r\n}\r\n\r\nconst loadMorePhotos = () => {\r\n    let index = ++pageIndex;\r\n    let galleryItem = document.querySelector('article');\r\n    let dataPhoto = galleryItem.getAttribute('data-photo')\r\n    if (dataPhoto == 'curated'){\r\n        getInitialRandomPhotos(index);\r\n    }else{\r\n        getMoreSearchedPhotos(index);\r\n    }\r\n}\r\n\r\n\r\n/****  EVENTOS  ****/\r\n\r\n// Evento submit del form, donde se llama a una función que trae las fotos a partir de la búsqueda.\r\nsearchForm.addEventListener('submit', (e) => getSearchedPhotos(e));\r\nloadMoreBtn.addEventListener('click', () => loadMorePhotos());\r\n// Cuando se carge la ventana, llamamos a la función que nos carga 8 fotos simulando que son fotos aleatorias.\r\ndocument.addEventListener('DOMContentLoaded', getInitialRandomPhotos(pageIndex));\r\n\r\n// Botón para limpiar el input del form.\r\nclearInputButton.addEventListener('click', () => {\r\n    let pageIndex = 1;\r\n    // Limpiamos el input.\r\n    document.getElementById('searchInput').value = '';\r\n    // Cuando la galería tiene 3 hijos es porque no se tuvo que crear el h2 para error. Sino, si se tuvo que crear el h2 por lo que tiene más hijos.\r\n    /* if (gallery.childNodes.length == 3){\r\n        // Borra los hijos del contenedor de la galería.\r\n        removeAllChild(galleryContainer);\r\n        // Carga las fotos aleatorias del principio.\r\n        getInitialRandomPhotos(pageIndex);\r\n    }else{\r\n        // Borra el h2 con el error.\r\n        gallery.childNodes[1].remove();\r\n        // Carga las fotos aleatorias del principio.\r\n        getInitialRandomPhotos(pageIndex);\r\n    } */\r\n    removeAllChild(galleryContainer);\r\n    getInitialRandomPhotos(pageIndex);\r\n    loadMoreBtn.style.display = 'flex';\r\n});\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Toggle theme functionality\r\n\r\nlet toggleTheme = document.getElementById('toggleTheme');\r\nlet ball = document.getElementById('ball');\r\nlet theme = localStorage.getItem('theme');\r\n\r\n// Creamos una función que nos permita habiltar el tema oscuro de la página, agregando la clase correspondiente al body y seteando el local storage para guardar el modo.\r\nconst enableDarkTheme = () => {\r\n    document.body.classList.add('dark-theme');\r\n    localStorage.setItem('theme', 'darkTheme');\r\n    ball.style.transform = 'translateX(20px)';\r\n}\r\n\r\n// Creamos una función que nos permita deshabiltar el tema oscuro de la página, removiendo la clase al body y seteando el local storage para guardar el modo.\r\nconst disableDarkTheme = () => {\r\n    document.body.classList.remove('dark-theme');\r\n    localStorage.setItem('theme', 'normal');\r\n    ball.style.transform = 'translateX(0)';\r\n}\r\n\r\ntheme === 'darkTheme' ? enableDarkTheme() : disableDarkTheme();\r\n\r\n// Cuando se aplique el evento click al botón toggle, si el local storage 'theme' no es 'darkTheme', lo habilitamos y sino lo deshabilitamos.\r\ntoggleTheme.addEventListener('click', () => {\r\n    // Actualizamos el local storage cuando se hace click.\r\n    theme = localStorage.getItem('theme');\r\n    theme != 'darkTheme' ? enableDarkTheme() : disableDarkTheme();\r\n});\r\n\r\n"],"file":"script.js"}