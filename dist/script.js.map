{"version":3,"names":[],"mappings":"","sources":["script.js"],"sourcesContent":["/* \r\nCreamos un objeto teniendo en cuenta los parámetros que nos devuelve la API en la docmuentación de la misma. \r\nLink: https://www.pexels.com/es-es/api/documentation/#photos-overview.\r\n*/\r\nclass Photo {\r\n    /* constructor(id, url, src, photographer, alt){\r\n        this.id = id; // Nro identificador de cada foto en particular.\r\n        this.url = url; // URL de la imagen original subida en Pexels.\r\n        this.src = src; // URL de la imagen para ser utilizada en nuestro proyecto.\r\n        this.photographer = photographer; // Nombre del fotografo.\r\n        this.alt = alt; // Texto descriptivo de la imagen el cual usa la API para filtrar y devolver resultados de búsqueda.\r\n    } */\r\n    // Creamos el constructor de la clase a partir de las propiedades del objeto dado por un json de una API.\r\n    constructor (json){\r\n        Object.assign(this, json);\r\n    }\r\n    showModal(){\r\n        galleryItem.addEventListener('click', () => {\r\n            Swal.fire({\r\n                imageUrl: this.src,\r\n                imageHeight: 500,\r\n                imageAlt: this.alt\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n// Creamos una función para generar Id's aleatorios. \r\nconst generateId = () => {\r\n    let id = Math.floor(Math.random() * 999) + 1;\r\n    return id;\r\n}\r\n\r\n// Creamos un array que simule el json que devuelve una API. Los primeros 8 elementos representan fotos random. El resto representan fotos para ser buscadas.\r\nconst apiPhotos = [\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/example (1).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/example (2).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/example (3).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/example (4).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/example (5).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/example (6).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/example (7).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/example (8).jpeg', photographer: '', alt: ''},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/caballomontaña.jpg', photographer: 'Jose Molina', alt: 'Caballos en montaña'},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/gatosaltando.jpg', photographer: 'Ignacio Fernandez', alt: 'Gato saltando'},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/formula1.jpg', photographer: 'Martin Caro', alt: 'Autos de Formula 1'},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/buenosaires.jpg', photographer: 'Beatriz Quiroga', alt: 'Buenos Aires'},\r\n    {id: generateId(), url: 'ejemploURL', src: '/dist/assets/images/personamontaña.jpg', photographer: 'Jose Molina', alt: 'Persona en montaña'}\r\n];\r\n\r\nlet errorAlert = document.getElementById('errorAlert');\r\nlet clearInputButton = document.getElementById('clearInput');\r\nlet searchForm = document.getElementById('searchForm');\r\nlet gallery = document.getElementById('gallery');\r\nlet galleryContainer = document.getElementById('galleryContainer');\r\nlet galleryItem = document.getElementsByClassName('gallery__item');\r\n\r\n// Creamos una función que nos permita validar si lo que ingresa el usuario cumple el requisito especificado. Si no lo cumple devuelve 'false', y si lo cumple devuelve 'true'. \r\nconst validateSearch = (word) => {\r\n    // Verificamos si la palabra posee más de 3 caracteres. \r\n    if (word.length < 3){\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}\r\n\r\n// Creamos una función que nos permita eliminar todos los hijos de un elemento.\r\nconst removeAllChild = (parent) => {\r\n    // Evalua que mientras tenga hijos, los va a eliminar.\r\n    while (parent.firstChild) {\r\n        parent.removeChild(parent.firstChild);\r\n    }\r\n}\r\n\r\n// Creamos una función que nos permita crear nuevos elementos (fotos) para la galería.\r\nconst createNewGalleryItem = (photoObject) => {\r\n    // Creamos un nuevo objeto 'Photo' a partir del objeto que nos dá el 'json'.\r\n    const photo = new Photo(photoObject);\r\n    // Creamos un nuevo elemento article.\r\n    let newGalleryItem = document.createElement('article');\r\n    // Le asignamos la clase que define los estilos que poseerán las fotos.\r\n    newGalleryItem.classList.add('gallery__item');\r\n    // Y le ponemos una etiqueta img con los datos del objeto para que se muestren.\r\n    newGalleryItem.innerHTML = `<img src=\"${photo.src}\" alt=\"${photo.alt}\"></img>`;\r\n    // Y por último le agregamos ese nuevo elemento a la galería. Utilicé el 'prepend' ya que quiero que se agregue al principio, para respetar el orden que simulo en el array.\r\n    galleryContainer.prepend(newGalleryItem);\r\n}\r\n\r\n// Creamos una función que nos permita saber si lo que ingresa el usuario coincide de alguna forma con el atributo 'Alt' de alguna foto. \r\nconst filterPhotos = (search) => {\r\n    // Filtramos el array de objetos para ver si la palabra buscada se encuentra en el alt de la foto. \r\n    let filteredPhotos = apiPhotos.filter(photo => photo.alt.toLowerCase().includes(search));\r\n    /* \r\n    Array.filter() devuelve un array nuevo si se cumple la condición y uno vacío si no se cumple. \r\n    Comprobamos si el array está vacío, es decir, que la plabra buscada no matcheó con ningún objeto de nuestro array(simulador de base de datos). \r\n    */\r\n    if (filteredPhotos.length === 0){\r\n        // Mostramos que ocurrió un error mediante un h2.\r\n        gallery.innerHTML = `<h2>No se pudo encontrar ninguna foto relacionada a \"${search}\".</h2>`;\r\n    } else{\r\n        // Eliminamos todas las fotos de la gelería.\r\n        removeAllChild(galleryContainer);\r\n        // Aplicando la función 'forEach' de orden superior. Por cada foto filtrada devolvemos un nuevo elemento para la galería.\r\n        filteredPhotos.forEach((photo) => {\r\n            // Llamamos la función que crea un nuevo elemento de la galería. 'photo' simula un objeto de un json que nos devuelve la API.\r\n            createNewGalleryItem(photo);\r\n        });\r\n    }\r\n}\r\n\r\n// Creamos una función que al cargarse la página simule que se trajeron fotos aleatoriamente. La misma cargará 8 fotos.\r\nconst getInitialRandomPhotos = (photosArray) => {\r\n    let firstEightItems = photosArray.slice(0, 8);\r\n    firstEightItems.forEach((photo) => {\r\n        createNewGalleryItem(photo);\r\n    });\r\n}\r\n\r\n// Eveneto submit del form, donde se llama a una función que trae las fotos a partir de la búsqueda.\r\nsearchForm.addEventListener('submit', (e) => {\r\n    getSearchedPhotos(e);\r\n});\r\n\r\n// Botón para limpiar el input del form.\r\nclearInputButton.addEventListener('click', () => {\r\n    document.getElementById('searchInput').value = '';\r\n    removeAllChild(galleryContainer);\r\n    getInitialRandomPhotos(apiPhotos);\r\n    errorAlert.innerText = '';\r\n});\r\n\r\n\r\n// Creamos una función que nos permita tomar lo que el usuario ingresa en la barra de búsqueda y fijarnos si matchea con alguna de las fotos que tenemos guardadas en el array (simulador de base de datos).\r\nconst getSearchedPhotos = (e) => {\r\n    // Evitamos el funcionamiento por defualt del evento submit.\r\n    e.preventDefault();\r\n    // Tomamos al input del form y lo almacenamos.\r\n    let inputSearch = e.target.querySelector('input');\r\n    // Y también guardamos el value en otra.\r\n    const userSearch = inputSearch.value;\r\n    // Validamos el value del input.\r\n    if (validateSearch(userSearch) === true){\r\n        // Cuando sea 'true', llamamos a la función que filtra.\r\n        filterPhotos(userSearch);\r\n        errorAlert.innerText = '';\r\n    } else{\r\n        // Cuando sea 'false', avisamos el error.\r\n        errorAlert.innerText = 'Debe introducir una palabra mayor a 3 letras';\r\n    }\r\n}\r\n\r\n// Cuando se carge la ventana, llamamos a la función que nos carga 8 fotos simulando que son fotos aleatorias.\r\nwindow.addEventListener('load', () => {\r\n    getInitialRandomPhotos(apiPhotos);\r\n});\r\n\r\n// Toggle theme functionality\r\n\r\nlet toggleTheme = document.getElementById('toggleTheme');\r\nlet ball = document.getElementById('ball');\r\nlet theme = localStorage.getItem('theme');\r\n\r\n// Creamos una función que nos permita habiltar el tema oscuro de la página, agregando la clase correspondiente al body y seteando el local storage para guardar el modo.\r\nconst enableDarkTheme = () => {\r\n    document.body.classList.add('dark-theme');\r\n    localStorage.setItem('theme', 'darkTheme');\r\n    ball.style.transform = 'translateX(20px)';\r\n}\r\n\r\n// Creamos una función que nos permita deshabiltar el tema oscuro de la página, removiendo la clase al body y seteando el local storage para guardar el modo.\r\nconst disableDarkTheme = () => {\r\n    document.body.classList.remove('dark-theme');\r\n    localStorage.setItem('theme', 'normal');\r\n    ball.style.transform = 'translateX(0)';\r\n}\r\n\r\ntheme === 'darkTheme' ? enableDarkTheme() : disableDarkTheme();\r\n\r\n// Cuando se aplique el evento click al botón toggle, si el local storage 'theme' no es 'darkTheme', lo habilitamos y sino lo deshabilitamos.\r\ntoggleTheme.addEventListener('click', () => {\r\n    // Actualizamos el local storage cuando se hace click.\r\n    theme = localStorage.getItem('theme');\r\n    theme != 'darkTheme' ? enableDarkTheme() : disableDarkTheme();\r\n});\r\n\r\n"],"file":"script.js"}